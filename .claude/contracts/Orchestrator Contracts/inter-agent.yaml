# Inter-Agent Communication Contract

## Overview

This contract defines the format for direct agent-to-agent communication, bypassing the Orchestrator for tightly-coupled agent interactions.

## When to Use Inter-Agent Communication

Inter-agent communication is appropriate when:
- Agents form a natural pipeline (e.g., Causal Impact → Explainer)
- Real-time data sharing is required
- Orchestrator routing would add unnecessary latency
- Agents need to share intermediate state

## Communication Patterns

### 1. Request-Response Pattern

Standard synchronous communication between agents.

```yaml
inter_agent_request:
  source_agent: string        # Requesting agent
  target_agent: string        # Target agent
  request_type: string        # Type of request
  correlation_id: string      # For tracing
  payload: object             # Request data
  timeout_ms: int             # Request timeout
```

```yaml
inter_agent_response:
  source_agent: string        # Responding agent
  target_agent: string        # Original requester
  correlation_id: string      # Matching correlation_id
  status: string              # "success" | "error"
  payload: object             # Response data
  latency_ms: int             # Processing time
```

### 2. Event Pattern

Asynchronous event publication for loose coupling.

```yaml
inter_agent_event:
  source_agent: string        # Publishing agent
  event_type: string          # Event type
  event_id: string            # Unique event ID
  timestamp: string           # ISO 8601
  payload: object             # Event data
  subscribers: list           # Optional: specific subscribers
```

### 3. Shared Context Pattern

For agents that need to share state without formal requests.

```yaml
shared_context:
  context_id: string          # Context identifier
  owner_agent: string         # Agent that owns context
  authorized_agents: list     # Agents with access
  data: object                # Shared data
  ttl_seconds: int            # Time-to-live
  version: int                # For optimistic locking
```

## Common Inter-Agent Flows

### Causal Impact → Explainer

```yaml
# Causal Impact produces analysis
causal_to_explainer:
  source_agent: "causal_impact"
  target_agent: "explainer"
  request_type: "explain_analysis"
  payload:
    analysis_type: "causal_effect_estimation"
    results:
      treatment: string
      outcome: string
      ate: float
      confidence_interval: [float, float]
      robustness: object
    user_expertise: string
    output_format: string
```

### Experiment Designer → Causal Impact

```yaml
# Experiment Designer requests causal graph validation
designer_to_causal:
  source_agent: "experiment_designer"
  target_agent: "causal_impact"
  request_type: "validate_dag"
  payload:
    dag_specification:
      treatment: string
      outcome: string
      confounders: list
      mediators: list
      instruments: list
    historical_data_available: bool
```

### Gap Analyzer → Resource Optimizer

```yaml
# Gap Analyzer provides opportunities for optimization
gap_to_optimizer:
  source_agent: "gap_analyzer"
  target_agent: "resource_optimizer"
  request_type: "optimize_allocation"
  payload:
    gaps:
      - entity_id: string
        gap_size: float
        expected_response: float
        current_allocation: float
    constraints:
      - constraint_type: string
        value: float
    objective: string
```

### Drift Monitor → Feedback Learner

```yaml
# Drift Monitor reports drift for learning
drift_to_learner:
  source_agent: "drift_monitor"
  target_agent: "feedback_learner"
  request_type: "report_drift"
  payload:
    drift_type: string
    affected_features: list
    severity: string
    drift_metrics:
      psi: float
      p_value: float
    timestamp: string
```

### Prediction Synthesizer → Explainer

```yaml
# Prediction Synthesizer requests explanation
prediction_to_explainer:
  source_agent: "prediction_synthesizer"
  target_agent: "explainer"
  request_type: "explain_prediction"
  payload:
    prediction:
      entity_id: string
      point_estimate: float
      confidence_interval: [float, float]
    model_contributions:
      - model_id: string
        prediction: float
        weight: float
    feature_importance: object
    user_expertise: string
```

### Heterogeneous Optimizer → Experiment Designer

```yaml
# Heterogeneous Optimizer requests experiment for segment
het_to_designer:
  source_agent: "heterogeneous_optimizer"
  target_agent: "experiment_designer"
  request_type: "design_segment_experiment"
  payload:
    segment_definition:
      features: object
      size: int
    hypothesized_cate: float
    confidence: float
    recommended_treatment_rate: float
```

## Event Types

### Model Events

```yaml
event_types:
  model_events:
    - model_deployed
    - model_retired
    - model_performance_degraded
    - model_retrained
```

### Data Events

```yaml
event_types:
  data_events:
    - data_refresh_complete
    - data_quality_issue
    - baseline_updated
    - schema_changed
```

### Analysis Events

```yaml
event_types:
  analysis_events:
    - analysis_complete
    - experiment_concluded
    - assumption_violation_detected
    - new_insight_discovered
```

## Error Handling

### Timeout Handling

```yaml
timeout_response:
  source_agent: string
  target_agent: string
  correlation_id: string
  status: "timeout"
  error:
    code: "AGENT_TIMEOUT"
    message: "Target agent did not respond within timeout"
    timeout_ms: int
```

### Agent Unavailable

```yaml
unavailable_response:
  source_agent: string
  target_agent: string
  correlation_id: string
  status: "error"
  error:
    code: "AGENT_UNAVAILABLE"
    message: "Target agent is not available"
    retry_after_ms: int
```

## Circuit Breaker Pattern

Agents should implement circuit breaker for inter-agent calls:

```yaml
circuit_breaker:
  agent: string
  target_agent: string
  state: "closed" | "open" | "half_open"
  failure_count: int
  failure_threshold: int
  reset_timeout_ms: int
  last_failure: string
```

## Validation Rules

1. **source_agent**: Must be valid registered agent
2. **target_agent**: Must be valid registered agent  
3. **correlation_id**: Must be unique per request chain
4. **timeout_ms**: Must be reasonable for target agent's latency class
5. **payload**: Must conform to target agent's input contract

## Monitoring

All inter-agent communications should emit:

```yaml
inter_agent_metric:
  source_agent: string
  target_agent: string
  request_type: string
  latency_ms: int
  status: string
  timestamp: string
  trace_id: string
```
